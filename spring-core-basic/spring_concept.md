Spring 핵심 원리 - 기본
===

### Spring?
- 문맥에 따라 다르게 사용
  1. 스프링 DI 컨테이너 기술
  2. 스프링 프레임워크
  3. 스프링 부트, 스프링 프레임워크 등을 모두 포함하는 스프링 생태계

### Spring의 핵심
- 자바 언어가 가지는 <b><u>객체 지향 언어</u></b>라는 특징을 살려내는 프레임워크
- 좋은 객체 지향 Application을 개발할 수 있게 도와주는 프레임워크
<br />
<br />
<br />
<hr />

### 다형성 : 객체 지향 프로그래밍의 핵심
- 객체의 역할과 구현을 구분
    - 역할 = 인터페이스
    - 구현 = 인터페이스 구현 클래스

- 클라이언트가 역할에만 의존하는 것으로 구현체의 변경에 대해 영향을 받지 않으므로 변경에 편리하고 유연해짐

- 단, 인터페이스(역할)의 변경에는 클라이언트와 서버가 모두 크게 영향을 받기 때문에, <b>인터페이스를 안정적으로 잘 설계하는 것이 중요</b>

- 스프링의 IoC, DI는 이러한 다형성을 극대화해서 이용할 수 있도록 도와줌!
<br />
<br />
<br />
<hr />

### 좋은 객체 지향 설계의 5원칙 : SOLID

<br />

1. 단일 책임 원칙 : SRP
    - 하나의 클래스에는 하나의 책임
    - 실제로는 하나의 책임이라는 것이 모호할 수 있음
    - <b>판단 기준은 변경</b> - 변경이 있을 때, 파급효과가 적다면 SRP를 잘 따른 것

2. 개방-폐쇄 원칙 : OCP
    - 소프트웨어 요소는 <u>확장에는 열려 있으나, 변경에는 닫혀있어야 한다.</u>
    - 다형성을 활용 - 인터페이스를 구현하는 새로운 클래스를 만들어 새로운 기능을 구현!
    - 그러나, 새로운 클래스를 만들더라도 클라이언트 측의 서버 객체 생성 코드의 변경이 발생 -> 객체의 생성 및 연관관계를 맺어주는 무언가가 필요!

3. 리스코프 치환 원칙 : LSP
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - 즉, 인터페이스의 구현체는 인터페이스가 요구하는 대로 작동해야 한다는 뜻!

4. 인터페이스 분리 원칙 : ISP
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 여러 클라이언트가 존재한다면 각 클라이언트에 대해 인터페이스를 정의하는 편이 <u>인터페이스가 명확해지며, 대체 가능성이 높아짐</u>

5. 의존관계 역전 원칙 : DIP
    - 프로그래머는 <u>추상화에 의존해야지, 구체화에 의존하면 안된다.</u>
    - 그러나, 특별한 요소의 도움없이는 클라이언트가 특정 객체를 사용할 때에 해당 객체를 생성하는 과정에서 구현 클래스에 의존하게 됨..!

<br />

<b>결론적으로 다형성 만으로는 OCP, DIP를 지킬 수 없다!</b>

이를 해결하기 위해, 스프링에서 제공하는 DI(Dpendency Injection) 컨테이너를 사용할 수 있음
        
<br />
<br />
<br />
<hr />

### 관심사의 분리

- Application이 하나의 공연이라고 할 때, 배역(역할 == 인터페이스)에 맞는 배우(구현 == 실제 객체)를 선택하는 것은 공연 기획자의 역할!

- 클라이언트가 구현체를 의존하는 것은 극의 배우가 상대 배우를 직접 초빙하는 것 같은 상황 => 그래선 안됨

- <b><u>구현 객체를 생성, 연결</u></b>(==DI)하는 책임을 스프링 컨테이너가 담당
    - DI(Dependency Injection) : 의존관계 주입, 객체의 의존관계 설정 책임을 분리하는 것으로 마치 외부에서 의존관계를 주입하는 것 같다고 하여 의존관계 주입, 의존성 주입이라고 함

- 객체의 생성과 연결의 역할을 분리하여 DIP 달성!

<br />
<br />
<br />
<hr />

### IoC, DI, 컨테이너

##### IoC(Inversion of Control) : 제어의 역전
- 프레임워크 같은 것들이 코드를 대신 호출하는 것 즉, <u>프로그램의 제어 흐름을 직접 제어하는 것이 아닌 외부에서 관리하는 것</u>
- 개발자 입장에서 자연스러운 흐름 : 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행
- Framework vs. Library
    - Framework : 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크(e.g.) JUnit)
    - Library : 내가 작성한 코드가 직접 제어의 흐름을 담당하면 라이브러리

##### DI(Dependency Injection) : 의존관계 주입
- 의존관계에서 <u>정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존관계</u>의 구분이 필요
    - 정적인 클래스 의존관계 : import 코드만으로도 판단 가능한 의존관계, Application 실행 없이도 분석 가능
    - 동적인 객체 인스턴스 의존관계 : Application 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 관계

- Application 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달하여 실제 의존관계(== 동적인 객체 인스턴스 의존관계)가 연결되는 것이 <b>의존관계 주입(DI)</b>

- 의존관계 주입을 통해 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 의존관계를 쉽게 변경하는 것이 가능!

##### IoC 컨테이너, DI 컨테이너

- IoC 컨테이너 or DI 컨테이너 : 객체를 생성하고 관리하면서 의존관계를 연결해주는 것
- 최근에는 주로 DI 컨테이너로 칭함
- 스프링 외에도 여러 DI 컨테이너 존재


<br />
<br />
<br />
<hr />

### Spring Container


- 스프링 컨테이너 == ApplicationContext
- ApplicationContext : 인터페이스로 어노테이션 기반, XML 기반 등 설정 방식을 따르는 구현체가 존재
- 정확히는 BeanFactory와 ApplicationContext로 구분하지만, 일반적으로는 BeanFactory를 직접 사용하는 경우가 거의 없기 때문에 ApplicationContext를 지칭
- 스프링 컨테이너 생성
    1. 구성 정보에 따라, 스프링 컨테이너에 Spring Bean을 저장 (** 빈 이름이 중복되면 문제 발생 가능)
    2. 구성 정보에 따라, 스프링 빈 사이의 의존관계 설정
    - 즉, 스프링 빈을 생성하는 단계와 의존관계를 주입하는 단계로 나뉨

##### BeanFactory
- 스프링 컨테이너의 최상위 인터페이스
- Bean을 관리하고 조회하는 역할 : getBean 메서드 제공

##### ApplicationContext
- BeanFactory를 상속받아 제공
- 이외에도 여러 application 개발에 필요한 부가기능을 상속받아 제공
    - MessageSource를 활용한 국제화 기능 : 국가에 따른 언어로 제공
    - EnviromentCapable : 로컬, 개발, 운영 등을 구분해서 처리
    - ApplicationEventPublisher : 애플리케이션 이벤트를 발행, 구독하는 모델 지원
    - ResourceLoader : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
- 따라서, BeanFactory를 직접 사용하는 일은 거의 없고, 보통 ApplicationContext를 사용


<br />
<br />
<hr />

###  설정 형식 지원

1. AnnotationConfigApplicationContext
    - annotation 기반 자바코드로 설정
    - new AnnotationConfigApplicationContext(설정클래스.class)

2. GenericXmlApplicationContext
    - 최근에는 스프링 부트를 사용하여 잘 사용 X
    - GenericApplicationContext를 사용하면서 xml로 된 설정 정보를 전달

<br />
<br />
<hr />

### BeanDefinition

- 다양한 설정 형식 지원이 가능한 이유 : BeanDefinition으로 추상화
- xml 또는 자바 코드를 읽어서 BeanDefinition을 만듦
- 따라서, BeanDefinition을 빈 설정 메타정보라고 함 -> 스프링 컨테이너는 메타정보를 기반으로 스프링 빈을 구성

<br />
<br />
<hr />

### 싱글톤 컨테이너

- 스프링은 기업용 온라인 서비스 기술을 지원하기 위해 탄생 + 대부분 스프링 어플리케이션은 웹 어플리케이션 -> 여러 고객이 동시에 요청
- 싱글톤 패턴 : 객체를 미리 생성해두고, 필요한 경우 생성된 새롭게 객체를 생성하는 것이 아닌 생성해놓은 객체를 호출하여 사용
    - 요청에 따라 객체 생성 X -> 비용 절감
    - 필요한 코드의 양이 많아짐, 클라이언트가 구체 클래스에 의존하면서 DIP 위반, OCP 위반 가능성이 높아지는 등 여러 문제점 존재
- 스프링 컨테이너는 이러한 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리
    - 스프링 컨테이너가 싱글톤 컨테이너 역할
    - 싱글톤 패턴을 위한 코드 불필요
    - DIP, OCP, private 생성자 등에서 자유롭게 싱글톤 사용 가능
- 따라서, 스프링을 사용하면 싱글톤으로 존재하는 객체를 호출하여 사용
    - 스프링의 기본 빈 등록 방식은 싱글톤이나, 다른 방식도 사용가능. But, 주로 싱글톤만 사용하긴 한다~


##### 주의점
- 싱글톤 패턴, 싱글톤 컨테이너와 같이 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 <u>stateless로 설계</u>해야 함!
    - 특정 클라이언트에 의존적인 field X
    - 특정 클라이언트가 값을 변경할 수 있는 field X
    - 가급적 읽기만 가능해야
    - field 대신 공유되지 않는 자원을 사용

<br />
<br />
<hr />

### @Configuration

- config 코드에 new를 사용하지만 싱글톤 패턴은 깨지지 않음 why?
- 바이트 코드 조작 라이브러리(CGLIB) 사용하여 설정 정보 클래스를 상속받은 임의의 클래스를 만들고 스프링 빈으로 등록
- Bean이 붙은 메서드에 대해 이미 spring bean이 존재한다면 존재하는 bean을 반환하고, 없으면 생성 -> 싱글톤 보장

<br />
<br />
<hr />

### 컴포넌트 스캔

- @Bean이나 xml을 사용하여 빈을 설정하면 스프링 빈이 많아질 경우 설정정보가 커지며 관리가 어려워질 수 있음
- 빈으로 사용할 클래스에 @Component 어노테이션을 붙이면 @ComponentScan이 해당 클래스를 스프링 빈으로 사용
    - 빈 이름 기본 : 스프링 빈의 기본 이름은 맨 앞글자를 소문자로 바꾼 클래스명을 사용
    - 빈 이름 지정 : @Component("memberService")와 같이 빈 이름을 직접 지정 가능

##### @Autowired
- 의존관계 자동 주입
- 생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당하는 빈을 찾아 주입
- 기본 전략 : 타입이 같은 빈을 주입

##### 탐색 위치와 기본 스캔 대상
- @ComponentScan에 basePackages를 파라미터로 전달하여 탐색할 패키지의 시작 위치를 지정
- 지정한 패키지를 포함하여 하위 패키지를 모두 탐색
- 지정하지 않으면 @ComponentScan이 붙은 설정 정보 클래스의 패키지에서 시작
    - 관례상, 설정 정보 클래스를 프로젝트 최상단에 위치
    - 스프링부트 사용 시 @SpringBootApplication 내부에 @ComponentScan이 존재하므로 해당 클래스를 최상단에 위치

##### 컴포넌트 스캔 기본 대상
- @Component, @Controller, @Service, @Repository, @Configuration 등


- 이러한 어노테이션들은 내부적으로 @Component를 포함

- 어노테이션에는 상속 관계 X -> 어떤 어노테이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 아닌 스프링이 지원하는 기능

##### 중복 등록
- 같은 빈 이름을 등록하는 두 가지 상황
     1. 자동 빈 등록 vs 자동 빈 등록
        - 오류 발생 : ConflictingBeanDefinitionException 에외
     2. 수동 빈 등록 vs 자동 빈 등록
        - 수동 빈 등록이 우선
        - 수동 빈이 자동 빈을 오버라이딩
    - 개발자가 이런 상황을 의도할 수도 있지만 아주 권장 되지 않음!
        - 그냥 이름 다 다르게..
    - 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류 발생으로 기본 값 변경
     
