Spring 핵심 원리 - 기본
===

### Spring?
- 문맥에 따라 다르게 사용
  1. 스프링 DI 컨테이너 기술
  2. 스프링 프레임워크
  3. 스프링 부트, 스프링 프레임워크 등을 모두 포함하는 스프링 생태계

### Spring의 핵심
- 자바 언어가 가지는 <b><u>객체 지향 언어</u></b>라는 특징을 살려내는 프레임워크
- 좋은 객체 지향 Application을 개발할 수 있게 도와주는 프레임워크
<br />
<br />
<br />
<hr />

### 다형성 : 객체 지향 프로그래밍의 핵심
- 객체의 역할과 구현을 구분
    - 역할 = 인터페이스
    - 구현 = 인터페이스 구현 클래스

- 클라이언트가 역할에만 의존하는 것으로 구현체의 변경에 대해 영향을 받지 않으므로 변경에 편리하고 유연해짐

- 단, 인터페이스(역할)의 변경에는 클라이언트와 서버가 모두 크게 영향을 받기 때문에, <b>인터페이스를 안정적으로 잘 설계하는 것이 중요</b>

- 스프링의 IoC, DI는 이러한 다형성을 극대화해서 이용할 수 있도록 도와줌!
<br />
<br />
<br />
<hr />

### 좋은 객체 지향 설계의 5원칙 : SOLID

<br />

1. 단일 책임 원칙 : SRP
    - 하나의 클래스에는 하나의 책임
    - 실제로는 하나의 책임이라는 것이 모호할 수 있음
    - <b>판단 기준은 변경</b> - 변경이 있을 때, 파급효과가 적다면 SRP를 잘 따른 것

2. 개방-폐쇄 원칙 : OCP
    - 소프트웨어 요소는 <u>확장에는 열려 있으나, 변경에는 닫혀있어야 한다.</u>
    - 다형성을 활용 - 인터페이스를 구현하는 새로운 클래스를 만들어 새로운 기능을 구현!
    - 그러나, 새로운 클래스를 만들더라도 클라이언트 측의 서버 객체 생성 코드의 변경이 발생 -> 객체의 생성 및 연관관계를 맺어주는 무언가가 필요!

3. 리스코프 치환 원칙 : LSP
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - 즉, 인터페이스의 구현체는 인터페이스가 요구하는 대로 작동해야 한다는 뜻!

4. 인터페이스 분리 원칙 : ISP
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 여러 클라이언트가 존재한다면 각 클라이언트에 대해 인터페이스를 정의하는 편이 <u>인터페이스가 명확해지며, 대체 가능성이 높아짐</u>

5. 의존관계 역전 원칙 : DIP
    - 프로그래머는 <u>추상화에 의존해야지, 구체화에 의존하면 안된다.</u>
    - 그러나, 특별한 요소의 도움없이는 클라이언트가 특정 객체를 사용할 때에 해당 객체를 생성하는 과정에서 구현 클래스에 의존하게 됨..!

<br />

<b>결론적으로 다형성 만으로는 OCP, DIP를 지킬 수 없다!</b>

이를 해결하기 위해, 스프링에서 제공하는 DI(Dpendency Injection) 컨테이너를 사용할 수 있음
        
<br />
<br />
<br />
<hr />

### 관심사의 분리

- Application이 하나의 공연이라고 할 때, 배역(역할 == 인터페이스)에 맞는 배우(구현 == 실제 객체)를 선택하는 것은 공연 기획자의 역할!

- 클라이언트가 구현체를 의존하는 것은 극의 배우가 상대 배우를 직접 초빙하는 것 같은 상황 => 그래선 안됨

- <b><u>구현 객체를 생성, 연결</u></b>(==DI)하는 책임을 스프링 컨테이너가 담당
    - DI(Dependency Injection) : 의존관계 주입, 객체의 의존관계 설정 책임을 분리하는 것으로 마치 외부에서 의존관계를 주입하는 것 같다고 하여 의존관계 주입, 의존성 주입이라고 함

- 객체의 생성과 연결의 역할을 분리하여 DIP 달성!

<br />
<br />
<br />
<hr />

### IoC, DI, 컨테이너

##### IoC(Inversion of Control) : 제어의 역전
- 프레임워크 같은 것들이 코드를 대신 호출하는 것 즉, <u>프로그램의 제어 흐름을 직접 제어하는 것이 아닌 외부에서 관리하는 것</u>
- 개발자 입장에서 자연스러운 흐름 : 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행
- Framework vs. Library
    - Framework : 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크(e.g.) JUnit)
    - Library : 내가 작성한 코드가 직접 제어의 흐름을 담당하면 라이브러리

##### DI(Dependency Injection) : 의존관계 주입
- 의존관계에서 <u>정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존관계</u>의 구분이 필요
    - 정적인 클래스 의존관계 : import 코드만으로도 판단 가능한 의존관계, Application 실행 없이도 분석 가능
    - 동적인 객체 인스턴스 의존관계 : Application 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 관계

- Application 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달하여 실제 의존관계(== 동적인 객체 인스턴스 의존관계)가 연결되는 것이 <b>의존관계 주입(DI)</b>

- 의존관계 주입을 통해 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 의존관계를 쉽게 변경하는 것이 가능!

##### IoC 컨테이너, DI 컨테이너

- IoC 컨테이너 or DI 컨테이너 : 객체를 생성하고 관리하면서 의존관계를 연결해주는 것
- 최근에는 주로 DI 컨테이너로 칭함
- 스프링 외에도 여러 DI 컨테이너 존재


<br />
<br />
<br />
<hr />

### Spring Container


- 스프링 컨테이너 == ApplicationContext
- ApplicationContext : 인터페이스로 어노테이션 기반, XML 기반 등 설정 방식을 따르는 구현체가 존재
- 정확히는 BeanFactory와 ApplicationContext로 구분하지만, 일반적으로는 BeanFactory를 직접 사용하는 경우가 거의 없기 때문에 ApplicationContext를 지칭
- 스프링 컨테이너 생성
    1. 구성 정보에 따라, 스프링 컨테이너에 Spring Bean을 저장 (** 빈 이름이 중복되면 문제 발생 가능)
    2. 구성 정보에 따라, 스프링 빈 사이의 의존관계 설정
    - 즉, 스프링 빈을 생성하는 단계와 의존관계를 주입하는 단계로 나뉨

##### BeanFactory
- 스프링 컨테이너의 최상위 인터페이스
- Bean을 관리하고 조회하는 역할 : getBean 메서드 제공

##### ApplicationContext
- BeanFactory를 상속받아 제공
- 이외에도 여러 application 개발에 필요한 부가기능을 상속받아 제공
    - MessageSource를 활용한 국제화 기능 : 국가에 따른 언어로 제공
    - EnviromentCapable : 로컬, 개발, 운영 등을 구분해서 처리
    - ApplicationEventPublisher : 애플리케이션 이벤트를 발행, 구독하는 모델 지원
    - ResourceLoader : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
- 따라서, BeanFactory를 직접 사용하는 일은 거의 없고, 보통 ApplicationContext를 사용


<br />
<br />
<hr />

###  설정 형식 지원

1. AnnotationConfigApplicationContext
    - annotation 기반 자바코드로 설정
    - new AnnotationConfigApplicationContext(설정클래스.class)

2. GenericXmlApplicationContext
    - 최근에는 스프링 부트를 사용하여 잘 사용 X
    - GenericApplicationContext를 사용하면서 xml로 된 설정 정보를 전달

<br />
<br />
<hr />

### BeanDefinition

- 다양한 설정 형식 지원이 가능한 이유 : BeanDefinition으로 추상화
- xml 또는 자바 코드를 읽어서 BeanDefinition을 만듦
- 따라서, BeanDefinition을 빈 설정 메타정보라고 함 -> 스프링 컨테이너는 메타정보를 기반으로 스프링 빈을 구성

<br />
<br />
<hr />

### 싱글톤 컨테이너

- 스프링은 기업용 온라인 서비스 기술을 지원하기 위해 탄생 + 대부분 스프링 어플리케이션은 웹 어플리케이션 -> 여러 고객이 동시에 요청
- 싱글톤 패턴 : 객체를 미리 생성해두고, 필요한 경우 생성된 새롭게 객체를 생성하는 것이 아닌 생성해놓은 객체를 호출하여 사용
    - 요청에 따라 객체 생성 X -> 비용 절감
    - 필요한 코드의 양이 많아짐, 클라이언트가 구체 클래스에 의존하면서 DIP 위반, OCP 위반 가능성이 높아지는 등 여러 문제점 존재
- 스프링 컨테이너는 이러한 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리
    - 스프링 컨테이너가 싱글톤 컨테이너 역할
    - 싱글톤 패턴을 위한 코드 불필요
    - DIP, OCP, private 생성자 등에서 자유롭게 싱글톤 사용 가능
- 따라서, 스프링을 사용하면 싱글톤으로 존재하는 객체를 호출하여 사용
    - 스프링의 기본 빈 등록 방식은 싱글톤이나, 다른 방식도 사용가능. But, 주로 싱글톤만 사용하긴 한다~


##### 주의점
- 싱글톤 패턴, 싱글톤 컨테이너와 같이 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 <u>stateless로 설계</u>해야 함!
    - 특정 클라이언트에 의존적인 field X
    - 특정 클라이언트가 값을 변경할 수 있는 field X
    - 가급적 읽기만 가능해야
    - field 대신 공유되지 않는 자원을 사용

<br />
<br />
<hr />

### @Configuration

- config 코드에 new를 사용하지만 싱글톤 패턴은 깨지지 않음 why?
- 바이트 코드 조작 라이브러리(CGLIB) 사용하여 설정 정보 클래스를 상속받은 임의의 클래스를 만들고 스프링 빈으로 등록
- Bean이 붙은 메서드에 대해 이미 spring bean이 존재한다면 존재하는 bean을 반환하고, 없으면 생성 -> 싱글톤 보장

<br />
<br />
<hr />

### 컴포넌트 스캔

- @Bean이나 xml을 사용하여 빈을 설정하면 스프링 빈이 많아질 경우 설정정보가 커지며 관리가 어려워질 수 있음
- 빈으로 사용할 클래스에 @Component 어노테이션을 붙이면 @ComponentScan이 해당 클래스를 스프링 빈으로 사용
    - 빈 이름 기본 : 스프링 빈의 기본 이름은 맨 앞글자를 소문자로 바꾼 클래스명을 사용
    - 빈 이름 지정 : @Component("memberService")와 같이 빈 이름을 직접 지정 가능

##### @Autowired
- 의존관계 자동 주입
- 생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당하는 빈을 찾아 주입
- 기본 전략 : 타입이 같은 빈을 주입

##### 탐색 위치와 기본 스캔 대상
- @ComponentScan에 basePackages를 파라미터로 전달하여 탐색할 패키지의 시작 위치를 지정
- 지정한 패키지를 포함하여 하위 패키지를 모두 탐색
- 지정하지 않으면 @ComponentScan이 붙은 설정 정보 클래스의 패키지에서 시작
    - 관례상, 설정 정보 클래스를 프로젝트 최상단에 위치
    - 스프링부트 사용 시 @SpringBootApplication 내부에 @ComponentScan이 존재하므로 해당 클래스를 최상단에 위치

##### 컴포넌트 스캔 기본 대상
- @Component, @Controller, @Service, @Repository, @Configuration 등


- 이러한 어노테이션들은 내부적으로 @Component를 포함

- 어노테이션에는 상속 관계 X -> 어떤 어노테이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 아닌 스프링이 지원하는 기능

##### 중복 등록
- 같은 빈 이름을 등록하는 두 가지 상황
     1. 자동 빈 등록 vs 자동 빈 등록
        - 오류 발생 : ConflictingBeanDefinitionException 에외
     2. 수동 빈 등록 vs 자동 빈 등록
        - 수동 빈 등록이 우선
        - 수동 빈이 자동 빈을 오버라이딩
    - 개발자가 이런 상황을 의도할 수도 있지만 아주 권장 되지 않음!
        - 그냥 이름 다 다르게..
    - 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류 발생으로 기본 값 변경
     

<br />
<br />
<hr />

### 의존관계 자동 주입

##### 의존관계 주입 방법
1. 생성자 주입
    - 생성자에 @Autowired
    - 생성자 호출 시점에 1번만 호출 보장
    - 불변, 필수 의존관계에 사용
    - 생성자가 단 하나 뿐이면 @Autowired 생략 가능
2. 수정자 주입
    - setter에 @Autowired
    - 선택, 변경 의존관계에 사용
    - @Autowired(required = false) 이면 선택 가능한 경우 - 주입할 대상이 없어도 동작하도록
3. 필드 주입
    - 필드에 @Autowired
    - 코드가 간결하지만, 외부에서 변경이 불가능 -> 테스트 어려움
    - 따라서, 권장하지 않음 -> 사용하지 말자!
    - 사용하는 경우
        - 애플리케이션과 실제 관련 없는 테스트 코드 내에서
        - 컨테이너만 사용하는 @Configuration 클래스에서
        - 특별한 용도로 사용
4. 일반 메서드 주입
    - 아무 일반 메서드에 @Autowired
    - 한 번에 여러 필드 주입 가능
    - 거의 사용하지 않음

##### 옵션 처리

- 주입할 스프링 빈이 없어도 동작해야 되는 경우
    - @Autowired(required = false)
        - 자동 주입할 대상이 없으면 수정자 메서드 호출이 안됨
    - org.springframework.lang.@Nullable
        - 자동 주입할 대상이 없으면 null이 입력
    - Optional<>
        - 자동 주입할 대상이 없으면 Optional.empty가 입력

##### 생성자 주입 선택의 이유
1. 불변
    - 대부분의 의존관계는 불변
    - 수정자 주입을 사용하면 setter를 열어 두어야하는데, 이런 경우 변경의 가능성이 발생
2. 누락
    - 프레임워크 없이 순수 자바 코드를 테스트 하는 경우, 생성자를 사용해야 필요한 가짜 객체를 사용하기 용이
3. final 키워드
    - 생성자 주입을 사용하는 경우에만 final 키워드 사용 가능

##### 조회한 빈이 2개 이상인 경우
- 3가지 해결방법 존재
1. @Autowired 필드 명 매칭
    - 필드 명을 빈 이름으로 변경
    - e.g.) discountPolicy -> rateDiscountPolicy
    - 매커니즘
        1. 타입 매칭
        2. 타입 매칭 결과가 2개 이상이면 필드명, 파라미터 명으로 빈 이름 매칭
2. @Quilifier
    - 추가 구분자를 붙여주는 방법
    - 주입시에 @Quilifier를 붙여주고 등록한 이름을 기입
    - 매커니즘
        1. @Quilifier끼리 매칭
        2. 빈 이름으로 매칭
        3. 그래도 실패시 NoSuchBeanDefinitionException 발생

3. @Primary
    - 우선순위를 지정하는 방법
    - 여러 빈이 매칭되면 @Primary가 우선권

- 사용 예시
    - 자주 사용하는 메인 DB의 커넥션을 획득하는 스프링 빈과 특별한 기능으로 가끔 사용하는 서브 DB의 커넥션을 획득하는 스프링 빈이 있는 경우
    - 메인 DB의 커넥션을 획득하는 스프링 빈을 @Primary 지정
    - 서브 DB의 커넥션을 획들할 때에는 @Quilifier를 지정하여 명시적으로 획득

- @Primary 보다 @Quilifier의 우선권이 높음

##### 조회한 빈을 모두 사용
- e.g.) 클라이언트가 할인정책을 선택하는 경우(fix, rate) 등
- Map, List로 해당하는 타입의 모든 스프링 빈을 주입
- 다형성을 활용하여 유연한 전략패턴 사용 가능

##### 실무 운영 기준
- 자동 기능을 기본으로 사용
    - 시간이 갈 수록 자동을 선호하는 추세
    - @Controller, @Service, @Repository 등과 같이 계층에 맞춰 스캔할 수 있도록 지원
- 수동 빈 등록의 사용 시기
    1. 애플리케이션은 크게 업무 로직, 기술 지원 로직으로 구분
        - 업무 로직 빈 : 컨트롤러, 비즈니스 로직이 있는 서비스 계층, 데이터 계층의 로직을 처리하는 리포지토리 등, 비즈니스 요구사항 개발 시 추가, 변경
        - 기술 지원 빈 : 기술적 문제나 공통관심사(AOP)를 처리할 때 주로 사용 -> DB 연결, 공통 로그 처리 등의 업무 로직 지원을 위한 하부 기술, 공통 기술
    - 업무 로직은 숫자도 많고, 유사한 패턴이 존재 -> 자동 기능 권장
    - 기술 지원 로직은 업무로직과 비교하여 수가 적고, 애플리케이션 전반에 광범위하게 영향 + 적용이 잘되는지 아닌지 파악도 어려움 -> 수동 빈 등록으로 명확하게 드러내는 것 권장

    2. 비즈니스 로직 중 다형성을 적극 활용할 때
        - List, Map을 사용하는 경우 등
        - 어떤 빈들이 주입될 지 한 눈에 보기 좋으려면 수동 빈 등록 권장
        - 자동으로 하더라도 특정 패키지에 같이 묶어두는 것 권장
        - 한 눈에 이해되게!

<br />
<br />
<hr />

### 빈 생명주기 콜백

- DB 커넥션 풀이나 네트워크 소켓과 같이 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 종료 시점에 연결을 모두 종료하는 작업을 하려면, 객체의 초기화와 종료 작업 필요
- 스프링 또한, 이러한 초기화 작업과 종료 작업을 진행

- 스프링 빈의 Life Cycle : 객체 생성 -> 의존관계 주입
- 따라서, 초기화 작업은 의존관계 주입이 모두 완료된 다음 호출 -> 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능 제공 + 스프링 컨테이너가 종료되기 직전에 소멸 콜백

- 스프링 빈의 이벤트 Life Cycle
    1. 스프링 컨테이너 생성
    2. 스프링 빈 생성
    3. 의존관계 주입
    4. 초기화 콜백
    5. 사용
    6. 소멸전 콜백
    7. 스프링 종료

- 객체의 생성과 초기화는 분리!
    - 생성자의 책임은 필수 정보를 받고, 메모리를 할당하여 객체를 생성하는 책임
    - 반면, 초기화는 생성도니 값들을 활용하여 커넥션을 연결하는 등 무거운 동작 수행
    - 따라서, 유지보수 관점에서 초기화는 별도의 초기화 메서드로 제공하는 것을 권장

- InitializingBean, DisposableBean 인터페이스
    - InitializingBean의 afterPropertiesSet 메서드로 초기화 지원
    - DisposableBean의 destroy 메서드로 소멸 지원
    - 단점 
        1. 스프링 전용 인터페이스로 코드가 스프링 전용 인터페이스에 의존
        2. 초기화, 소멸 메서드의 이름 변경 불가
        3. 직접 코드를 고칠 수 없는 외부 라이브러리에 적용 불가
    - 스프링 초창기에 나온 방식으로 현재는 거의 사용 X

- 빈 등록 시점 초기화, 소멸 메서드
    - @Bean(initMethod = "init", destroyMethod = "close") 와 같은 식으로 초기화 종료 메서드를 지정
    - 자유롭게 메스드 이름 설정
    - 빈이 스프링 코드에 의존 X
    - 설정 정보를 사용하므로 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드 적용 가능

    - destoryMethod 속성에는 default로 '(inferred)'(추론)으로 등록
    - 대부분 라이브러리는 close, shutdown을 종료 메서드 이름으로 사용 
    - 추론 기능은 close, shutdown이라는 이름의 메서드를 자동으로 호출 -> 이름 그대로 추론!

- @PostContstruct, @PreDestroy
    - @PostContstruct : 초기화 메서드
    - @PreDestory : 종료 메서드
    - 가장 권장되는 방법
    - 스프링 종속적인 기술 X, 자바 표준 기술 -> 스프링이 아닌 컨테이너에서도 동작
    - @ComponentScan에 잘 어울리는 방식
    - 유일한 단점
        - 코드를 수정해야 하기 때문에 외부 라이브러리에 적용 불가
        - 외부 라이브러리를 초기화, 종료해야 할 때는 @Bean의 기능 사용 권장

<br />
<br />
<hr />

### 빈 스코프

- 스코프 : 빈이 존재할 수 있는 범위
    - 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
    - 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 관리 X, 매우 짧은 범위의 스코프
    - 웹 관련 스코프
        - request : 웹 요청이 들어오고 나갈때 까지 유지
        - session : 웹 세션이 생성되고 종료될 때 까지 유지
        - application : 웹 서블릿 컨텍스트와 같은 범위로 유지
    - @Bean, @Component 어노테이션과 함께 @Scope 어노테이션을 사용하여 지정 가능
