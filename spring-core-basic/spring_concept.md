Spring 핵심 원리 - 기본
===

### Spring?
- 문맥에 따라 다르게 사용
  1. 스프링 DI 컨테이너 기술
  2. 스프링 프레임워크
  3. 스프링 부트, 스프링 프레임워크 등을 모두 포함하는 스프링 생태계

### Spring의 핵심
- 자바 언어가 가지는 <b><u>객체 지향 언어</u></b>라는 특징을 살려내는 프레임워크
- 좋은 객체 지향 Application을 개발할 수 있게 도와주는 프레임워크
<br />
<br />
<br />
<hr />

### 다형성 : 객체 지향 프로그래밍의 핵심
- 객체의 역할과 구현을 구분
    - 역할 = 인터페이스
    - 구현 = 인터페이스 구현 클래스

- 클라이언트가 역할에만 의존하는 것으로 구현체의 변경에 대해 영향을 받지 않으므로 변경에 편리하고 유연해짐

- 단, 인터페이스(역할)의 변경에는 클라이언트와 서버가 모두 크게 영향을 받기 때문에, <b>인터페이스를 안정적으로 잘 설계하는 것이 중요</b>

- 스프링의 IoC, DI는 이러한 다형성을 극대화해서 이용할 수 있도록 도와줌!
<br />
<br />
<br />
<hr />

### 좋은 객체 지향 설계의 5원칙 : SOLID

<br />

1. 단일 책임 원칙 : SRP
    - 하나의 클래스에는 하나의 책임
    - 실제로는 하나의 책임이라는 것이 모호할 수 있음
    - <b>판단 기준은 변경</b> - 변경이 있을 때, 파급효과가 적다면 SRP를 잘 따른 것

2. 개방-폐쇄 원칙 : OCP
    - 소프트웨어 요소는 <u>확장에는 열려 있으나, 변경에는 닫혀있어야 한다.</u>
    - 다형성을 활용 - 인터페이스를 구현하는 새로운 클래스를 만들어 새로운 기능을 구현!
    - 그러나, 새로운 클래스를 만들더라도 클라이언트 측의 서버 객체 생성 코드의 변경이 발생 -> 객체의 생성 및 연관관계를 맺어주는 무언가가 필요!

3. 리스코프 치환 원칙 : LSP
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - 즉, 인터페이스의 구현체는 인터페이스가 요구하는 대로 작동해야 한다는 뜻!

4. 인터페이스 분리 원칙 : ISP
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 여러 클라이언트가 존재한다면 각 클라이언트에 대해 인터페이스를 정의하는 편이 <u>인터페이스가 명확해지며, 대체 가능성이 높아짐</u>

5. 의존관계 역전 원칙 : DIP
    - 프로그래머는 <u>추상화에 의존해야지, 구체화에 의존하면 안된다.</u>
    - 그러나, 특별한 요소의 도움없이는 클라이언트가 특정 객체를 사용할 때에 해당 객체를 생성하는 과정에서 구현 클래스에 의존하게 됨..!

<br />

<b>결론적으로 다형성 만으로는 OCP, DIP를 지킬 수 없다!</b>

이를 해결하기 위해, 스프링에서 제공하는 DI(Dpendency Injection) 컨테이너를 사용할 수 있음
        
<br />
<br />
<br />
<hr />

### 관심사의 분리

- Application이 하나의 공연이라고 할 때, 배역(역할 == 인터페이스)에 맞는 배우(구현 == 실제 객체)를 선택하는 것은 공연 기획자의 역할!

- 클라이언트가 구현체를 의존하는 것은 극의 배우가 상대 배우를 직접 초빙하는 것 같은 상황 => 그래선 안됨

- <b><u>구현 객체를 생성, 연결</u></b>(==DI)하는 책임을 스프링 컨테이너가 담당
    - DI(Dependency Injection) : 의존관계 주입, 객체의 의존관계 설정 책임을 분리하는 것으로 마치 외부에서 의존관계를 주입하는 것 같다고 하여 의존관계 주입, 의존성 주입이라고 함

- 객체의 생성과 연결의 역할을 분리하여 DIP 달성!

<br />
<br />
<br />
<hr />

### IoC, DI, 컨테이너

##### IoC(Inversion of Control) : 제어의 역전
- 프레임워크 같은 것들이 코드를 대신 호출하는 것 즉, <u>프로그램의 제어 흐름을 직접 제어하는 것이 아닌 외부에서 관리하는 것</u>
- 개발자 입장에서 자연스러운 흐름 : 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행
- Framework vs. Library
    - Framework : 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크(e.g.) JUnit)
    - Library : 내가 작성한 코드가 직접 제어의 흐름을 담당하면 라이브러리

##### DI(Dependency Injection) : 의존관계 주입
- 의존관계에서 <u>정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존관계</u>의 구분이 필요
    - 정적인 클래스 의존관계 : import 코드만으로도 판단 가능한 의존관계, Application 실행 없이도 분석 가능
    - 동적인 객체 인스턴스 의존관계 : Application 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 관계

- Application 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달하여 실제 의존관계(== 동적인 객체 인스턴스 의존관계)가 연결되는 것이 <b>의존관계 주입(DI)</b>

- 의존관계 주입을 통해 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 의존관계를 쉽게 변경하는 것이 가능!

##### IoC 컨테이너, DI 컨테이너

- IoC 컨테이너 or DI 컨테이너 : 객체를 생성하고 관리하면서 의존관계를 연결해주는 것
- 최근에는 주로 DI 컨테이너로 칭함
- 스프링 외에도 여러 DI 컨테이너 존재


<br />
<br />
<br />
<hr />

### Spring Container


- 스프링 컨테이너 == ApplicationContext
- ApplicationContext : 인터페이스로 어노테이션 기반, XML 기반 등 설정 방식을 따르는 구현체가 존재
- 정확히는 BeanFactory와 ApplicationContext로 구분하지만, 일반적으로는 BeanFactory를 직접 사용하는 경우가 거의 없기 때문에 ApplicationContext를 지칭
- 스프링 컨테이너 생성
    1. 구성 정보에 따라, 스프링 컨테이너에 Spring Bean을 저장 (** 빈 이름이 중복되면 문제 발생 가능)
    2. 구성 정보에 따라, 스프링 빈 사이의 의존관계 설정
    - 즉, 스프링 빈을 생성하는 단계와 의존관계를 주입하는 단계로 나뉨